% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/doeDesign.R
\docType{class}
\name{doeDesign-class}
\alias{doeDesign-class}
\title{A class representing a designed experiment.}
\description{
The doeDesign class represents all relevant information of a designed experiment.
That is not only the data table but different aspects, like the design model and
used optimality criterion as well.
}
\section{Slots}{

\describe{
\item{\code{responses}}{An optional list of names that are the responses measured in the experiment.}

\item{\code{factors}}{A list of objects of class \code{\link{doeFactor-class}} representing all factors of the DOE.}

\item{\code{check.validity}}{A function that represents constraints to the factor space. This function should test if all
rows of the design.table in the DOE are acceptable and return FALSE if this is not the case.}

\item{\code{number.runs}}{The number of experiments that are available for the experiment as an integer.}

\item{\code{replicate.type}}{CURRENTLY NOT USED.}

\item{\code{replicate.n}}{CURRENTLY NOT USED.}

\item{\code{whole.plot.structure}}{A data frame representing the whole plot structure of the design. The data frame must contain one column for each hard- and semi-hard-to-change-factor. The column name is the same like the factor name. The values represent blocks of experiments in which the corresponding factor is not varied independently.}

\item{\code{design.model}}{An object of class \code{\link{formula}} representing the design model for the DOE.}

\item{\code{design.matrix}}{A list containing the design matrix X and the matrix of random effects Y for the DOE.}

\item{\code{design.table}}{The actual data table that represents the experiments in the DOE.}

\item{\code{iteration.table}}{A \code{\link{data.frame}} representing in which order cells are modified during the design creation. This is only relevant for internal use.}

\item{\code{variance.ratio}}{A numeric representing the variance ratio of residual variance to whole-plot-variance. This is relevant for the generation of optimal split-plot-designs.}

\item{\code{replicate.structure}}{CURRENTLY NOT USED.}

\item{\code{optimality.function}}{A function that calculates the optimality of a design. It is assumed that larger values of optimality represent better designs. The function has to accept an object of class \code{\link{doeDesign-class}} as argument.}

\item{\code{optimality.criterion}}{A character representing the name of the used optimality criterion.}

\item{\code{optmiality}}{A numeric representing the actual value of the optimality criterion for the current design.}
}}

\examples{

# A simple completely randomized design
crmd <- GenerateNewDoeDesign(
    factors = list(
       new("doeFactor", name="X1", levels=c(0, 1)),
       new("doeFactor", name="X2", levels=c(0, 1))
    ),
    number.runs = as.integer(20),
    design.model = ~X1*X2,
    random.doe = TRUE
)
crmd

# A split plot design
splitplot <- GenerateNewDoeDesign(
    factors = list(
       new("doeFactor", name="X1", levels=c("A", "B", "C"), type="categorical", changes="hard"),
       new("doeFactor", name="X2", levels=c(0, 1))
    ),
    number.runs = as.integer(20),
    whole.plot.structure=data.frame(X1=rep(1:5, each=4)),
    design.model = ~X1*X2,
    random.doe = TRUE
)
splitplot # This is just a random design (not optimal)

# A design using semi hard to change factors
semisplitplot <- GenerateNewDoeDesign(
    factors = list(
       new("doeFactor", name="X1",
                        levels=c("A", "B", "C", "D"),
                        type="categorical",
                        changes="semi.hard",
                        semi.htc.group.size=as.integer(2)),
       new("doeFactor", name="X2", levels=c(0, 1))
    ),
    number.runs = as.integer(20),
    whole.plot.structure=data.frame(X1=rep(1:5, each=4)),
    design.model = ~X1*X2,
    optimality.function=DOptimality,
    optimality.criterion = "D-Optimality",
    random.doe = TRUE
)
GenerateOptimalDesign(semisplitplot, random.start = 1, max.iter = 5)

# Using constrained factor spaces
my.constraint <- function(doe){
 return(!any(doe@design.table$X1 > 0.5 & doe@design.table$X2 > 0.5))
}

constrained.doe <- GenerateNewDoeDesign(
    factors = list(
       new("doeFactor", name="X1", levels=c(0, 1)),
       new("doeFactor", name="X2", levels=c(0, 1))
    ),
    check.validity = my.constraint,
    number.runs = as.integer(20),
    design.model = ~X1*X2,
    random.doe = TRUE
) # This is just a random design (not optimal)

plot(constrained.doe@design.table$X1, constrained.doe@design.table$X2)

}
